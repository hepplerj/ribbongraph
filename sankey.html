
<!DOCTYPE html>
<html>
<meta charset="utf-8">
<title>Sankey Diagram</title>
<style>

body {
  font-family: sans-serif;
}

#chart {
  height: 500px;
}

.node rect {
  cursor: move;
  fill-opacity: .9;
  shape-rendering: crispedgesArray;
}

.node text {
  pointer-events: none;
  text-shadow: 0 1px 0 #fff;
}

.link {
  fill: none;
  stroke: #000;
  stroke-opacity: .2;
}

.link:hover {
  stroke-opacity: .5;
}

</style>
<body>

<h2>Sankey</h2>

<p id="chart">

<script src="lib/d3.v3.min.js" charset="utf-8"></script>
<script src="lib/queue.v1.min.js"></script>
<script src="lib/sankey.js"></script>

<script>

var margin = {top: 1, right: 1, bottom: 6, left: 1},
    width = 1300 - margin.left - margin.right,
    height = 1300 - margin.top - margin.bottom;

var formatNumber = d3.format(",.0f"),
    // format = function(d) { return formatNumber(d) + " TWh"; },
    color = d3.scale.category20();

var svg = d3.select("#chart").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var sankey = d3.sankey();
    // .nodeWidth(15)
    // .nodePadding(10)
    // .size([width, height]);

var path = sankey.link();

// ========================== Prepare data ==========================

queue()
    .defer(d3.csv, "data/grains.csv")
    .await(ready);


// ========================== Start viz ==========================

function ready(error, csv_data) {

  // graph = {"nodes": [], "links": []};

  nodes = [];
  edgesArray = [];
  nodesArray = [];

  csv_data.forEach(function (d, i) {
    d.index = i;
    d.value = +d.value;
  });

  // Scales
  yearScale = d3.scale.linear().domain([1640,1688]).range([20,width -20]);
  radiusScale = d3.scale.linear().domain([0,300]).range([2,12]).clamp(true);
  chargeScale = d3.scale.linear().domain([0,100]).range([0,-100]).clamp(true);
  uniqueValues = d3.set(nodesArray.map(function(d) {return d.translation})).values();
  colorScale = d3.scale.category20b(uniqueValues);
  sortScale = d3.scale.ordinal().domain(uniqueValues).rangePoints([-0.001,.001]);

  // Create a JSON link array
  // This creates unique nodes for each item and its corresponding date.
  // For example, nodes are rendered as "peas-1640," "peas-1641," etc.
  csv_data.forEach(function(link) {
      key = link.translation + '-' + link.date;
      link.source = nodes[key] || (nodes[key] = {translation: link.translation, date: link.date, origX: yearScale(parseInt(link.date)), value: link.value || 0});
      nodes.push(link);
  });

// Build the edgesArray array
// This creates the edgesArray to correspond with unique nodes. We're telling
// items and dates to remain together. So, the code below tells the graph
// layout that `1641` is preceded by `1640` and followed by `1642`, etc.
var y = "→";
  for (x in nodes) {
    nodesArray.push(nodes[x])
    if(nodes[y]) {
      nodes[y].date = parseInt(nodes[y].date);
      if (nodes[y].translation == nodes[x].translation) {
        var newLink = {source:nodes[y], target:nodes[x], value: +nodes[x].value}
        edgesArray.push(newLink);
      }
    }
    y = x;
  }

   console.log(nodesArray);
   console.log(edgesArray);
  // console.log(graph);

  // Build the graph
  // graph.nodes.push(nodesArray);
  // graph.links.push(edgesArray);

  sankey
      .nodeWidth(5)
      .nodePadding(3)
      .size([width, height])
      .nodes(nodesArray)//.filter(function(d,i) {return d.date < 1650}))
      .links(edgesArray)//.filter(function(d,i) { return i < 50 && d.source.date < 1650 &&  d.target.date < 1650} )) // filtering to test a smaller data set
      .layout(32);


  // // Sort the nodes by value
  // d3.values(nodesArray).forEach(function (d) {
  //   var y = ( height() - d3.sum(d, function(n) { return n.dy+sankey.nodePadding(); }) ) / 2 + sankey.nodePadding()/2;
  //   d.sort(function (a,b) {
  //     return b.dy - a.dy;
  //   })
  // });

  var link = svg.append("g").selectAll(".link")
     // .data(edgesArray)
      .data(edgesArray)//.filter(function(d,i) { return i < 50 && d.source.date < 1650 &&  d.target.date < 1650} )) // filtering to test a smaller data set
    .enter().append("path")
      .attr("class", "link")
      .attr("d", path)
      .style("stroke-width", function(d) { return Math.max(1, d.y); })
      .sort(function(a, b) { return b.y - a.y; });

  link.append("title")
      .text(function(d) { return d.source.translation + " → " + d.target.translation + "\n" + d.value; });

  var node = svg.append("g").selectAll(".node")
//      .data(nodesArray)
      .data(nodesArray)//.filter(function(d,i) { return d.date < 1650}))  // filtering to test a smaller data set
    .enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
    .call(d3.behavior.drag()
      .origin(function(d) { return d; })
      .on("dragstart", function() { this.parentNode.appendChild(this); })
      .on("drag", dragmove));

  node.append("rect")
      .attr("height", function(d) { return d.y; })
      .attr("width", sankey.nodeWidth())
      .style("fill", function(d) { return d.color = color(d.translation.replace(/ .*/, "")); })
      .style("stroke", function(d) { return d3.rgb(d.color).darker(2); })
    .append("title")
      .text(function(d) { return d.translation + "\n" + d.value; });

  node.append("text")
      .attr("x", -6)
      .attr("y", function(d) { return d.y / 2; })
      .attr("dy", ".35em")
      .attr("text-anchor", "end")
      .attr("transform", null)
      .text(function(d) { return d.translation; })
    .filter(function(d) { return d.x < width / 2; })
      .attr("x", 6 + sankey.nodeWidth())
      .attr("text-anchor", "start");

  function dragmove(d) {
    d3.select(this).attr("transform", "translate(" + d.x + "," + (d.y = Math.max(0, Math.min(height - d.y, d3.event.y))) + ")");
    sankey.relayout();
    link.attr("d", path);
  }
};

</script>
